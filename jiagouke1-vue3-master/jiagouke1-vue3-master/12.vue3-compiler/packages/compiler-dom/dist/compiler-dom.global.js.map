{"version":3,"file":"compiler-dom.global.js","sources":["../src/parse.ts","../src/transform.ts","../src/index.ts"],"sourcesContent":["export const enum NodeTypes {\n    ROOT, // fragment 解决多个根元素的问题\n    ElEMENT, // div、p\n    TEXT, // hello world\n    SIMPLE_EXPRESSION = 4, // {{name}}\n    INTERPOLATION = 5, // {{}}\n    COMPOUND_EXPRESSION = 8, // 组合表达式  {{name}} hello world\n    TEXT_CALL = 12, // createTextVnode\n    VNODE_CALL = 13, // \n    JS_CALL_EXPRESSION = 17\n}\n\nfunction isEnd(context) { // 是不是解析完毕 ：解析完毕的核心就是context.source = ''\n    const source = context.source;\n    if(source.startsWith('</')){\n        return true\n    }\n    return !source\n}\n\nfunction advanceSpaces(context){\n    const match = /^[ \\t\\r\\n]+/.exec(context.source);\n    if(match){\n       advanceBy(context, match[0].length)\n    }\n}\nfunction parseTag(context){\n    const start = getCursor(context); //<div/>\n    // 最基本的元字符\n    const match = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/.exec(context.source); // igm\n    const tag = match[1];\n    advanceBy(context,match[0].length);\n    advanceSpaces(context);\n\n    const isSelfClosing = context.source.startsWith('/>');\n    advanceBy(context,isSelfClosing?2:1);\n    return {\n        type:NodeTypes.ElEMENT,\n        tag,\n        isSelfClosing,\n        loc:getSelection(context,start)\n    }\n}\nfunction parseElement(context) {\n    // 1.解析标签名 \n    let ele:any = parseTag(context); // <div></div>\n\n    // 这里可能有儿子？\n    const children = parseChildren(context); // 这里处理儿子的时候 有可能没有儿子，那就直接跳出？ 如果遇到结束标签就直接跳出就好了\n\n    if(context.source.startsWith('</')){\n        parseTag(context); // 解析关闭标签时 同时会移除关闭信息并且更新偏移量\n    }\n    ele.children = children;\n    ele.loc = getSelection(context,ele.loc.start)\n    return ele;\n}\n\n\nfunction parseInterpolation(context) { // }}  {{name}}\n    const start = getCursor(context); // 获取表达式的start位置\n    const closeIndex = context.source.indexOf('}}', '{{')\n\n    advanceBy(context, 2);\n    const innerStart = getCursor(context);\n    const innerEnd = getCursor(context); // 这个end稍后我们会改\n    const rawContentLength = closeIndex - 2;// 拿到{{ 内容 }}  包含空格的\n\n    const preTrimContent = parseTextData(context,rawContentLength)  \n    const content = preTrimContent.trim(); // 去掉前后空格  \"  name  \"  name\n    const startOffset = preTrimContent.indexOf(content); // {{  name  }}\n    if(startOffset > 0){ // 有前面空格\n        advancePositionWithMutation(innerStart,preTrimContent,startOffset)\n    }\n    // 在去更新innerEnd ？ \n    const endOffset = content.length + startOffset\n    advancePositionWithMutation(innerEnd,preTrimContent,endOffset)\n    advanceBy(context,2);\n    return {\n        type:NodeTypes.INTERPOLATION,\n        content:{\n            type:NodeTypes.SIMPLE_EXPRESSION,\n            isStatic:false,\n            loc: getSelection(context,innerStart,innerEnd),\n            content\n        },\n        loc:getSelection(context,start)\n    }\n}\n\n\n\nfunction getCursor(context) {\n    let { line, column, offset } = context;\n    return { line, column, offset }\n}\n\nfunction advancePositionWithMutation(context, s, endIndex) {\n    // 如何更新时第几行?\n    let linesCount = 0;\n    let linePos = -1;\n    for (let i = 0; i < endIndex; i++) {\n        if (s.charCodeAt(i) == 10) { // 遇到换行就涨一行\n            linesCount++;\n            linePos = i; // 换行后第一个人的位置 \n        }\n    }\n    context.offset += endIndex;\n    context.line += linesCount;\n    context.column = linePos == -1 ? context.column + endIndex : endIndex - linePos\n    // 如何更新列数\n    // 更新偏移量\n}\nfunction advanceBy(context, endIndex) {\n    let s = context.source;// 原内容\n    // 计算出一个新的结束位置\n    advancePositionWithMutation(context, s, endIndex); // 根据内容和结束索引来修改上下文的信息\n    context.source = s.slice(endIndex); // 截取内容\n}\n\nfunction parseTextData(context, endIndex) {\n    const rawText = context.source.slice(0, endIndex);\n    advanceBy(context, endIndex); // 在context.source中把文本内容删除掉\n    return rawText\n}\nfunction getSelection(context, start,end?) { // 获取这个信息对应的开始、结束、内容\n     end = end || getCursor(context)\n    return {\n        start,\n        end,\n        source: context.originalSource.slice(start.offset, end.offset)\n    }\n}\nfunction parseText(context) { // 1.先做文本处理\n    const endTokens = ['<', '{{'];\n    let endIndex = context.source.length; // 文本的整个长度\n    // 假设法 需要先假设 遇到 <  是结尾  在拿到遇到{{  去比较那个 在前 就是到哪\n    for (let i = 0; i < endTokens.length; i++) {\n        const index = context.source.indexOf(endTokens[i], 1);\n        if (index !== -1 && endIndex > index) {\n            endIndex = index;\n        }\n    }\n    // 有了文本的结束位置 我就可以更新行列信息 \n    let start = getCursor(context);\n    const content = parseTextData(context, endIndex);\n    return {\n        type: NodeTypes.TEXT,\n        content,\n        loc: getSelection(context, start)\n    }\n}\nfunction parseChildren(context) { // 根据内容做不同的处理\n    const nodes = [];\n    while (!isEnd(context)) {\n        const s = context.source; // 当前上下文中的内容  <  abc  {{}}\n        let node;\n        if (s[0] == '<') { // 标签\n            node = parseElement(context)\n        } else if (s.startsWith('{{')) { // 表达式  \n            node = parseInterpolation(context);\n        } else {\n            node = parseText(context);\n        }\n        nodes.push(node)\n    }\n    nodes.forEach((node,index)=>{\n        if(node.type === NodeTypes.TEXT){\n            if(!/[^ \\t\\r\\n]/.test(node.content)){ // 只要没有内容，就删除掉\n                nodes[index] = null\n            }else{\n                node.content = node.content.replace(/[ \\t\\r\\n]+/g,' ')\n            }\n        }\n    })\n    return nodes.filter(Boolean); // 过滤null值\n}\nfunction createParserContext(content) {\n    return {\n        line: 1,\n        column: 1,\n        offset: 0,\n        source: content, // 这个source会被不停的移除？  等待source为空的时候解析完毕\n        originalSource: content // 这个值是不会变的 记录你传入的内容\n    }\n}\nfunction createRoot(children,loc){\n    return {\n        type:NodeTypes.ROOT,\n        children,\n        loc\n    }\n}\nexport function baseParse(content) {\n    // 标识节点的信息 行、列、偏移量...\n    // 我每解析一段 就移除一部分 \n    \n    const context = createParserContext(content);\n    const start = getCursor(context); // 记录开始位置\n    return createRoot(parseChildren(context),getSelection(context,start))\n}","import { PatchFlags } from \"@vue/shared/src\";\nimport { NodeTypes } from \"./parse\";\n\nexport const CREATE_VNODE = Symbol('createVnode');\nexport const TO_DISPALY_STRING = Symbol('toDisplayString');\nexport const OPEN_BLOCK = Symbol('openBlock');\nexport const CREATE_BLOCK = Symbol('createBlock')\nexport const FRAGMENT = Symbol('Fragment');\nexport const CREATE_TEXT = Symbol('createTextVNode');\n\nfunction createVnodeCall(context, tag, props, children, patchFlag) {\n    context.helper(CREATE_VNODE);\n    return {\n        type: NodeTypes.VNODE_CALL,\n        tag,\n        props,\n        children,\n        patchFlag\n    }\n}\nfunction transformElement(node, context) { // 专门处理元素的\n\n    // 希望在整个树处理完毕后 在处理元素 \n    if (node.type != NodeTypes.ElEMENT) { // 此节点是元素\n        return;\n    }\n    // ...\n    return () => { // 退出函数  洋葱模型 \n        // createVnode('h1',{},'helloworld',1) 向helper中添加一个createVnode\n        const { tag, children } = node\n        let vnodeTag = `'${tag}'`\n        let vnodeProps; // props处理是想对复杂\n        let vnodeChildren;  // 处理好的儿子\n        let vnodePatchFlag;\n        let patchFlag = 0; // 用于标记这个标签是不是动态的\n        if (children.length > 0) {\n            if (children.length == 1) {\n                const child = children[0];\n                const type = child.type;// 看一下他是不是动态\n                const hasDymanicTextChild = type === NodeTypes.INTERPOLATION || type === NodeTypes.COMPOUND_EXPRESSION;\n                if (hasDymanicTextChild) {\n                    patchFlag |= PatchFlags.TEXT\n                }\n                vnodeChildren = child; // 直接把一个儿子拿出来即可\n            } else {\n                vnodeChildren = children; // 多个儿子 不用处理\n            }\n        }\n        if (patchFlag !== 0) {\n            vnodePatchFlag = patchFlag + ''\n        }\n        node.codegenNode = createVnodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag);\n        console.log(context)\n    }\n}\n\nfunction isText(node) {\n    return node.type === NodeTypes.INTERPOLATION || node.type == NodeTypes.TEXT\n}\n\nfunction createCallExpression(callee, args) {\n    return {\n        type: NodeTypes.JS_CALL_EXPRESSION,\n        callee,\n        arguments: args\n    }\n}\nfunction transformText(node, context) { // 专门处理文本\n\n    // {{name}} hello  => [children,children]  => createTextNode(name + ‘hello’) \n    if (node.type == NodeTypes.ROOT || node.type == NodeTypes.ElEMENT) {\n        // ...\n        return () => {\n            // 对元素中的文本进行合并操作\n            let hasText = false;\n            let children = node.children;\n            let container = null;\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (isText(child)) { // \"hello hello\" + name (div) +world+ 'hello'\n                    hasText = true; // 当前元素确实有文本，我需要合并\n                    for (let j = i + 1; j < children.length; j++) {\n                        const next = children[j];\n                        if (isText(next)) {\n                            if (!container) {\n                                container = children[i] = {\n                                    type: NodeTypes.COMPOUND_EXPRESSION,\n                                    loc: child.loc,\n                                    children: [child]\n                                }\n                                container.children.push(`+`, next);\n                                children.splice(j, 1);\n                                j--;\n                            }\n                        } else {\n                            container = null;\n                            break; // 跳过\n                        }\n                    }\n                }\n            }\n            // 文本需要增加 createText方法 helper里增加\n            // <div>hello</div> \n            if (!hasText || children.length == 1) { // 只有一个孩子 在代码执行的时候 可以直接innerHTML 无需createText\n                return;\n            }\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (isText(child) || child.type == NodeTypes.COMPOUND_EXPRESSION) {\n                    const callArgs = []; // 用于存放参数的\n                    callArgs.push(child); // 文本内容\n                    if (child.type !== NodeTypes.TEXT) {\n                        callArgs.push(PatchFlags.TEXT + '');\n                    }\n                    children[i] = { // createTextNode('')\n                        type: NodeTypes.TEXT_CALL,\n                        content: child,\n                        loc: child.loc,\n                        codegenNode: createCallExpression( // 用于最后生成代码的\n                            context.helper(CREATE_TEXT),\n                            callArgs\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n\n// 树结构  树的每一个节点进行转化\nexport function getBaseTransformPreset() { // 很多转化的方法\n    return [\n        // 方法1 。。。\n        transformElement,\n        transformText\n    ]\n}\nexport function createTransformContext(root, nodeTransforms) {\n    const context = {\n        root,\n        currentNode: root, // 当前节点 会随着树的遍历而更新\n        nodeTransforms, //  上下文的目的时为了传参方法\n        helpers: new Set(),\n        helper(name) { // 代码中用到了具体方法 需要调用此方法 将对应的名字加入到helpers\n            context.helpers.add(name);\n            return name;\n        }\n    };\n    return context\n}\nfunction traverseChildren(node, context) { // 深度优先\n    for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        traverseNode(child, context);\n    }\n}\nfunction traverseNode(node, context) {\n    const { nodeTransforms } = context;\n    context.currentNode = node;\n    const exits = [];\n    for (let i = 0; i < nodeTransforms.length; i++) {\n        const onExit = nodeTransforms[i](node, context);\n        if (onExit) exits.push(onExit)\n    }\n    switch (node.type) {\n        case NodeTypes.ROOT:\n        case NodeTypes.ElEMENT:\n            traverseChildren(node, context);\n        case NodeTypes.INTERPOLATION:  // name => {obj:aaa}.TOsTRING\n            context.helper(TO_DISPALY_STRING)\n    }\n    let i = exits.length;\n\n    // 为了保证退出方法对应的context.currentNode是正确的\n    context.currentNode = node;\n    while (i--) {\n        exits[i]();\n    }\n}\n\nfunction createRootCodegen(root, context) {\n    const { helper } = context;\n    const children = root.children;\n    helper(OPEN_BLOCK)\n    helper(CREATE_BLOCK)\n    if (children.length == 1) {\n        const child = children[0]; // 直接以当前这个孩子作为根节点\n        const codegen = child.codegenNode; // 获取刚才元素转化后的codegen\n        codegen.isBlock = true; // 只有一个儿子 那么他就是blocktree的根节点\n       \n        root.codegenNode = codegen // 一个儿子直接把儿子的codegen挂载到最外层上\n    } else if (children.length > 1) {\n        root.codegenNode = createVnodeCall(\n            context, helper(FRAGMENT),\n            undefined,\n            children,\n            PatchFlags.STABLE_FRAGMENT)\n        root.codegenNode.isBlock=  true;\n    }\n   \n\n}\n\nexport function transform(root, nodeTransforms) {\n    const context = createTransformContext(root, nodeTransforms);\n    traverseNode(root, context);\n    createRootCodegen(root, context);\n\n    root.helpers = [...context.helpers] // context的属性 放到helpers上\n\n}\n","\nimport { baseParse, NodeTypes } from \"./parse\";\nimport { CREATE_BLOCK, CREATE_TEXT, CREATE_VNODE, FRAGMENT, getBaseTransformPreset, OPEN_BLOCK, TO_DISPALY_STRING, transform } from \"./transform\";\n\nexport const helperNameMap: any = {\n    [FRAGMENT]: `Fragment`,\n    [OPEN_BLOCK]: `openBlock`,\n    [CREATE_BLOCK]: `createBlock`,\n    [CREATE_VNODE]: `createVNode`,\n    [TO_DISPALY_STRING]: \"toDisplayString\",\n    [CREATE_TEXT]: \"createTextVNode\"\n}\nfunction createCodegenContext(ast) {\n    const newLine = (n) => {\n        context.push('\\n' + '  '.repeat(n))\n    }\n    const context = {\n        code: ``, // 拼的结果\n        push(c) { // 拼接代码\n            context.code += c;\n        },\n        helper(key){\n            return  `${helperNameMap[key]}`;\n        },\n        indentLevel: 0, // 缩进几次\n        newLine() {\n            newLine(context.indentLevel); // 换行\n        },\n        indent() {\n            newLine(++context.indentLevel); // 缩进\n        },\n        deindent() {\n            newLine(--context.indentLevel);\n        }\n    }\n    return context\n}\nfunction genVNodeCall(node,context){\n    const {push,helper} = context;\n    const {tag,children,props,patchFlag,isBlock} = node\n    if(isBlock){\n        push(`(${helper(OPEN_BLOCK)}(),`) \n        // 后面递归处理即可\n    }\n}\nfunction genNode(node, context) {\n    switch (node.type) {    \n        case NodeTypes.VNODE_CALL:\n            debugger;\n            genVNodeCall(node, context)         \n            break;\n        case NodeTypes.ElEMENT:\n            break;\n        case NodeTypes.TEXT:\n            break;\n        case NodeTypes.INTERPOLATION:\n            break\n        case NodeTypes.SIMPLE_EXPRESSION:\n            break;\n        case NodeTypes.COMPOUND_EXPRESSION:\n            break;\n        case NodeTypes.TEXT_CALL:\n            break;\n        case NodeTypes.JS_CALL_EXPRESSION:\n            break;\n    }\n}\nfunction generate(ast) {\n    const context = createCodegenContext(ast);\n    const { push, newLine, indent, deindent } = context;\n    push(`const _Vue = Vue`);\n    newLine();\n    push(`return function render(_ctx){`);\n    indent();\n    push(`with (_ctx) {`)\n    indent()\n    push(`const {${ast.helpers.map(s => `${helperNameMap[s]}`).join(',')}} = _Vue`);\n    newLine()\n    push(`return `); //需要根据转化后的结果 生成字符串\n    genNode(ast.codegenNode, context);\n    deindent();\n    push(`}`)\n    deindent();\n    push(`}`);\n    return context.code\n}\n\n\nexport function baseCompile(template) {\n    // 讲模板转换成ast语法树\n    const ast = baseParse(template);\n    // 将ast语法进行转化 （优化 静态提升 方法缓存  生成代码为了最终生成代码时使用）\n    const nodeTransforms = getBaseTransformPreset(); // nodeTransforms 每遍历到一个节点都要调用里面的方法\n    transform(ast, nodeTransforms);\n    // 根节点 的处理我在最外面 进行了一次包裹\n    return generate(ast); // 在生成的过程中 需要创建一个字符串拼接后的结果\n}\n\n\n// 最终结果还是new Function\n\n\n// 从 template - > ast语法树   (vue里面 有指令 有插槽 有事件)\n// ast - > transform -> codegen \n"],"names":[],"mappings":"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"}