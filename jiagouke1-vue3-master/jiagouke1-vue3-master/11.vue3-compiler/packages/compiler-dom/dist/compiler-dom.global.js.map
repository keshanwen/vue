{"version":3,"file":"compiler-dom.global.js","sources":["../src/index.ts"],"sourcesContent":["export const enum NodeTypes {\n    ROOT,\n    ElEMENT,\n    TEXT,\n    SIMPLE_EXPRESSION = 4,\n    INTERPOLATION = 5,\n    ATTRIBUTE = 6,\n    DIRECTIVE = 7,\n    COMPOUND_EXPRESSION = 8,\n    TEXT_CALL = 12,\n    VNODE_CALL = 13,\n}\n\nfunction isEnd(context) { // 是不是解析完毕 ：解析完毕的核心就是context.source = ''\n    const source = context.source;\n    if(source.startsWith('</')){\n        return true\n    }\n    return !source\n}\n\nfunction advanceSpaces(context){\n    const match = /^[ \\t\\r\\n]+/.exec(context.source);\n    if(match){\n       advanceBy(context, match[0].length)\n    }\n}\nfunction parseTag(context){\n    const start = getCursor(context); //<div/>\n    // 最基本的元字符\n    const match = /^<\\/?([a-z][^ \\t\\r\\n/>]*)/.exec(context.source); // igm\n    const tag = match[1];\n    advanceBy(context,match[0].length);\n    advanceSpaces(context);\n\n    const isSelfClosing = context.source.startsWith('/>');\n    advanceBy(context,isSelfClosing?2:1);\n    return {\n        type:NodeTypes.ElEMENT,\n        tag,\n        isSelfClosing,\n        loc:getSelection(context,start)\n    }\n}\nfunction parseElement(context) {\n    // 1.解析标签名 \n    let ele:any = parseTag(context); // <div></div>\n\n    // 这里可能有儿子？\n    const children = parseChildren(context); // 这里处理儿子的时候 有可能没有儿子，那就直接跳出？ 如果遇到结束标签就直接跳出就好了\n\n    if(context.source.startsWith('</')){\n        parseTag(context); // 解析关闭标签时 同时会移除关闭信息并且更新偏移量\n    }\n    ele.children = children;\n    ele.loc = getSelection(context,ele.loc.start)\n    return ele;\n}\n\n\nfunction parseInterpolation(context) { // }}  {{name}}\n    const start = getCursor(context); // 获取表达式的start位置\n    const closeIndex = context.source.indexOf('}}', '{{')\n\n    advanceBy(context, 2);\n    const innerStart = getCursor(context);\n    const innerEnd = getCursor(context); // 这个end稍后我们会改\n    const rawContentLength = closeIndex - 2;// 拿到{{ 内容 }}  包含空格的\n\n    const preTrimContent = parseTextData(context,rawContentLength)  \n    const content = preTrimContent.trim(); // 去掉前后空格  \"  name  \"  name\n    const startOffset = preTrimContent.indexOf(content); // {{  name  }}\n    if(startOffset > 0){ // 有前面空格\n        advancePositionWithMutation(innerStart,preTrimContent,startOffset)\n    }\n    // 在去更新innerEnd ？ \n    const endOffset = content.length + startOffset\n    advancePositionWithMutation(innerEnd,preTrimContent,endOffset)\n    advanceBy(context,2);\n    return {\n        type:NodeTypes.INTERPOLATION,\n        content:{\n            type:NodeTypes.SIMPLE_EXPRESSION,\n            isStatic:false,\n            loc: getSelection(context,innerStart,innerEnd)\n        },\n        loc:getSelection(context,start)\n    }\n}\n\n\n\nfunction getCursor(context) {\n    let { line, column, offset } = context;\n    return { line, column, offset }\n}\n\nfunction advancePositionWithMutation(context, s, endIndex) {\n    // 如何更新时第几行?\n    let linesCount = 0;\n    let linePos = -1;\n    for (let i = 0; i < endIndex; i++) {\n        if (s.charCodeAt(i) == 10) { // 遇到换行就涨一行\n            linesCount++;\n            linePos = i; // 换行后第一个人的位置 \n        }\n    }\n    context.offset += endIndex;\n    context.line += linesCount;\n    context.column = linePos == -1 ? context.column + endIndex : endIndex - linePos\n    // 如何更新列数\n    // 更新偏移量\n}\nfunction advanceBy(context, endIndex) {\n    let s = context.source;// 原内容\n    // 计算出一个新的结束位置\n    advancePositionWithMutation(context, s, endIndex); // 根据内容和结束索引来修改上下文的信息\n    context.source = s.slice(endIndex); // 截取内容\n}\n\nfunction parseTextData(context, endIndex) {\n    const rawText = context.source.slice(0, endIndex);\n    advanceBy(context, endIndex); // 在context.source中把文本内容删除掉\n    return rawText\n}\nfunction getSelection(context, start,end?) { // 获取这个信息对应的开始、结束、内容\n     end = end || getCursor(context)\n    return {\n        start,\n        end,\n        source: context.originalSource.slice(start.offset, end.offset)\n    }\n}\nfunction parseText(context) { // 1.先做文本处理\n    const endTokens = ['<', '{{'];\n    let endIndex = context.source.length; // 文本的整个长度\n    // 假设法 需要先假设 遇到 <  是结尾  在拿到遇到{{  去比较那个 在前 就是到哪\n    for (let i = 0; i < endTokens.length; i++) {\n        const index = context.source.indexOf(endTokens[i], 1);\n        if (index !== -1 && endIndex > index) {\n            endIndex = index;\n        }\n    }\n    // 有了文本的结束位置 我就可以更新行列信息 \n    let start = getCursor(context);\n    const content = parseTextData(context, endIndex);\n    return {\n        type: NodeTypes.TEXT,\n        content,\n        loc: getSelection(context, start)\n    }\n}\nfunction parseChildren(context) { // 根据内容做不同的处理\n    const nodes = [];\n    while (!isEnd(context)) {\n        const s = context.source; // 当前上下文中的内容  <  abc  {{}}\n        let node;\n        if (s[0] == '<') { // 标签\n            node = parseElement(context)\n        } else if (s.startsWith('{{')) { // 表达式  \n            node = parseInterpolation(context);\n        } else {\n            node = parseText(context);\n        }\n        nodes.push(node)\n    }\n    nodes.forEach((node,index)=>{\n        if(node.type === NodeTypes.TEXT){\n            if(!/[^ \\t\\r\\n]/.test(node.content)){ // 只要没有内容，就删除掉\n                nodes[index] = null\n            }else{\n                node.content = node.content.replace(/[ \\t\\r\\n]+/g,' ')\n            }\n        }\n    })\n    return nodes.filter(Boolean); // 过滤null值\n}\nfunction createParserContext(content) {\n    return {\n        line: 1,\n        column: 1,\n        offset: 0,\n        source: content, // 这个source会被不停的移除？  等待source为空的时候解析完毕\n        originalSource: content // 这个值是不会变的 记录你传入的内容\n    }\n}\n\nfunction createRoot(children,loc){\n    return {\n        type:NodeTypes.ROOT,\n        children,\n        loc\n    }\n}\nfunction baseParse(content) {\n    // 标识节点的信息 行、列、偏移量...\n    // 我每解析一段 就移除一部分 \n    \n    const context = createParserContext(content);\n    const start = getCursor(context); // 记录开始位置\n    return createRoot(parseChildren(context),getSelection(context,start))\n}\n\nexport function baseCompile(template) {\n    // 讲模板转换成ast语法树\n    const ast = baseParse(template);\n    return ast\n}\n\n \n// 从 template - > ast语法树   (vue里面 有指令 有插槽 有事件)\n// ast - > transform -> codegen \n"],"names":[],"mappings":"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"}